// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// @title Exposes basic functions to create, read, update and delete cards from user wallets.
/// @author Maxence P. <maxence.pawlowski@supinfo.com>
contract CardFactory {
    constructor() {}

    /// Properties
    /// @notice A card structure.
    /// @param cardId - The card identifier (generated by Counter).
    /// @param price - The card price.
    /// @param discountPercent - The card discount.
    /// @param owner - The card owner.
    /// @param approvedTo (optional) - The address approved for transfer.
    /// @param name - The card name.
    /// @param imagePath (optional) - The card image path.
    /// @param description (optional) - The card description.
    struct Card {
        uint256 cardId;
        uint256 price;
        uint8 discountPercent;
        address owner;
        address approvedTo;
        string name;
        string imagePath;
        string description;
    }

    /// Mappings
    mapping (address => Card[]) private userToCards;

    /// Modifier
    modifier checkIndex(address _owner, uint256 _index) {
        require(_index < _getCardsOf(_owner).length, "Invalid card index!");
        _;
    }

    /// Functions
    // Functions - Create
    /// @notice Adds a card to an address.
    /// @param _owner - The owner of the card.
    /// @param _card - The card.
    function _addCard(address _owner, Card memory _card) internal {
        userToCards[_owner].push(_card);
    }

    // Functions - Read
    /// @notice Get all cards of the function caller.
    /// @return The cards.
    function getCards() public view returns(Card[] memory) {
        return _getCardsOf(msg.sender);
    }

    // Functions - Read
    /// @notice Get all cards of specific address.
    /// @param _owner - The cards owner.
    /// @return The cards.
    function _getCardsOf(address _owner) internal view returns(Card[] memory) {
        return userToCards[_owner];
    }

    /// @notice Get a card of specific address by card index in wallet.
    /// @param _owner - The card owner.
    /// @param _index - The card wallet index.
    /// @return The card.
    function _getCard(address _owner, uint256 _index) internal view checkIndex(_owner, _index) returns(Card memory) {
        return userToCards[_owner][_index];
    }

    /// @notice Get the card index in user wallet.
    /// @param _owner - The card owner.
    /// @param _cardId - The card id.
    /// @return The card index.
    function _findCardIndex(address _owner, uint256 _cardId) internal view returns(uint256) {
        Card[] memory cards = _getCardsOf(_owner);

        for (uint256 idx = 0; idx < cards.length; idx++) {
            if (cards[idx].cardId == _cardId) {
                return idx;
            }
        }

        revert("Invalid card id!");
    }

    /// @notice Get card by id.
    /// @param _owner - The card owner.
    /// @param _cardId - The card id.
    /// @return The card.
    function _getCardById(address _owner, uint256 _cardId) internal view returns(Card memory) {
        return _getCard(_owner, _findCardIndex(_owner, _cardId));
    }

    // Functions - Update
    /// @notice Update a card.
    /// @param _owner - The card owner.
    /// @param _index - The card index in wallet.
    /// @param _card - The new card.
    function _setCard(address _owner, uint256 _index, Card memory _card) internal {
        userToCards[_owner][_index] = _card;
    }

    /// @notice Update a card approval.
    /// @param _owner - The card owner.
    /// @param _target - The target address to approve.
    /// @param _cardId - The card id.
    function _updateCardApproval(address _owner, address _target, uint256 _cardId) internal {
        uint256 index = _findCardIndex(_owner, _cardId);
        userToCards[_owner][index].approvedTo = _target;
    }

    // Functions - Delete
    /// @notice Delete a card from a user's wallet.
    /// @param _owner - The card owner.
    /// @param _cardId - The card id.
    function _removeCard(address _owner, uint256 _cardId) internal {
        // Delete the card
        Card[] storage cards = userToCards[_owner];
        uint256 idToRemove = _findCardIndex(_owner, _cardId);
        delete cards[idToRemove];

        // Sort the array and truncate it
        uint256 offset = 0;

        for (uint256 idx = 0; idx < cards.length; idx++) {
            if (offset > 0) {
                cards[idx - offset] = cards[idx];
            }

            if (cards[idx].discountPercent == 0) {
                offset++;
            }
        }

        for (uint256 i = 0; i < offset; i++) {
            cards.pop();
        }
    }
}
