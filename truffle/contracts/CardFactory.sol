pragma solidity ^0.8.0;
// SPDX-License-Identifier: UNLICENSED

import "./IUserWalletFactory.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "./Administrable.sol";

contract CardFactory is ERC721, Administrable {
    using Counters for Counters.Counter;
    Counters.Counter private _cardIdCounter;

    constructor(address walletAddr) ERC721("CardFactory", "CRD") {
        walletContract = IUserWalletFactory(walletAddr);
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, AccessControlEnumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    /// Constants
    struct Card {
        uint256 cardId; // token ID generated by Counter
        uint256 price;
        uint8 discountPercent;
        address owner;
        string name;
        string imagePath;
        string description;
        bool forSale;
    }

    IUserWalletFactory walletContract;

    /// Mappings
    mapping (uint => address) private cardApprovals;

    /// Events
    event BoughtCard(address owner, uint256 cardId);

    /// Modifiers
    modifier isOwnerOf(uint256 cardId) {
        require(super.ownerOf(cardId) == msg.sender);
        _;
    }

    /// Functions
    //function createCard() public mustBeAdmin {
        //uint256 cardId = safeMint(msg.sender);
        //walletContract._addCard(msg.sender, Card(cardId, 10, 10, msg.sender, "TEST", "", "DESCRIPTION"));
    //}

    function createCard(uint256 price, uint8 discountPercent, string calldata name, string calldata imagePath, string calldata description)
    external mustBeAdmin
    returns (uint256)
    {
        uint256 newCardId = _cardIdCounter.current();
        super._mint(msg.sender, newCardId);
        walletContract._addCard(msg.sender, Card(newCardId, price, discountPercent, msg.sender, name, imagePath, description, true));

        _cardIdCounter.increment();
        return newCardId;
    }

    function buyCard(address from, address to, uint256 cardId, uint256 price) public payable {
        require(msg.value == price);
        super.safeTransferFrom(from, to, cardId);
        emit BoughtCard(msg.sender, cardId);
    }

    function safeTransferFrom(address, address, uint256) override public pure {
        revert("You must use buyCard.");
    }

    function transferFrom(address, address, uint256) override public pure {
        revert("You must use buyCard.");
    }

    function changeSaleStatus(uint256 cardId, bool saleStatus) external isOwnerOf(cardId) {
        Card memory card = walletContract._getCard(cardId);
        card.forSale = saleStatus;
        walletContract._setCard(cardId, card);
    }
}
